Voici une description en français de l'algorithme de construction du graphe de de Bruijn pour une collection arbitraire de k-mers :

Étant donnée une collection arbitraire de k-mers *Patterns* (où certains k-mers peuvent apparaître plusieurs fois), on définit le *CompositionGraph(Patterns)* comme un graphe composé de \(|\text{Patterns}|\) arêtes isolées. Chaque arête est étiquetée par un k-mer de *Patterns*, et les nœuds de départ et d'arrivée d'une arête sont respectivement étiquetés par le préfixe et le suffixe du k-mer qui étiquette cette arête.

Le graphe de de Bruijn de *Patterns*, noté *DeBruijn(Patterns)*, est ensuite construit en fusionnant les nœuds ayant la même étiquette dans *CompositionGraph(Patterns)*.





Voici une implémentation en Python des fonctions pour construire le graphe de de Bruijn à partir d'une collection de k-mers.

```python
from collections import defaultdict

def composition_graph(patterns):
    """
    Construit le CompositionGraph de la collection de k-mers Patterns.
    Renvoie un dictionnaire où chaque préfixe est associé à un suffixe en tant qu'arête isolée.
    """
    edges = []
    for kmer in patterns:
        prefix = kmer[:-1]
        suffix = kmer[1:]
        edges.append((prefix, suffix))
    return edges

def de_bruijn_graph(patterns):
    """
    Construit le graphe de de Bruijn DeBruijn(Patterns) à partir de la collection de k-mers Patterns.
    Renvoie le graphe sous forme de liste d'adjacence.
    """
    adj_list = defaultdict(list)
    edges = composition_graph(patterns)
    
    # Construire la liste d'adjacence en fusionnant les nœuds ayant des étiquettes identiques
    for prefix, suffix in edges:
        adj_list[prefix].append(suffix)
    
    return dict(adj_list)

# Exemple d'utilisation
patterns = ["AAG", "AGG", "GGA", "GAT", "ATC"]
de_bruijn = de_bruijn_graph(patterns)
print(de_bruijn)
```

### Explication
1. La fonction `composition_graph` prend en entrée une liste de k-mers, et pour chaque k-mer, elle crée une arête isolée en séparant le k-mer en son préfixe et suffixe.
2. La fonction `de_bruijn_graph` construit le graphe de de Bruijn en fusionnant les nœuds ayant des étiquettes identiques. Elle renvoie ensuite un dictionnaire représentant la liste d'adjacence, où chaque clé est un préfixe, et les valeurs sont les suffixes correspondants.

En exécutant cet exemple avec `patterns = ["AAG", "AGG", "GGA", "GAT", "ATC"]`, la sortie sera la liste d'adjacence du graphe de de Bruijn construit.












D'accord, voici une version du code sans utiliser `defaultdict`. 

```python
def composition_graph(patterns):
    """
    Construit le CompositionGraph de la collection de k-mers Patterns.
    Renvoie une liste d'arêtes où chaque arête est représentée par un tuple (préfixe, suffixe).
    """
    edges = []
    for kmer in patterns:
        prefix = kmer[:-1]
        suffix = kmer[1:]
        edges.append((prefix, suffix))
    return edges

def de_bruijn_graph(patterns):
    """
    Construit le graphe de de Bruijn DeBruijn(Patterns) à partir de la collection de k-mers Patterns.
    Renvoie le graphe sous forme de liste d'adjacence sans utiliser defaultdict.
    """
    adj_list = {}
    edges = composition_graph(patterns)
    
    # Construire la liste d'adjacence en fusionnant les nœuds ayant des étiquettes identiques
    for prefix, suffix in edges:
        if prefix in adj_list:
            adj_list[prefix].append(suffix)
        else:
            adj_list[prefix] = [suffix]
    
    return adj_list

# Exemple d'utilisation
patterns = ["AAG", "AGG", "GGA", "GAT", "ATC"]
de_bruijn = de_bruijn_graph(patterns)
print(de_bruijn)
```

### Explication
1. La fonction `composition_graph` génère une liste d'arêtes en créant un tuple `(préfixe, suffixe)` pour chaque k-mer.
2. Dans `de_bruijn_graph`, au lieu d'utiliser `defaultdict`, on vérifie si le préfixe est déjà dans `adj_list`. Si oui, on ajoute le suffixe à la liste existante. Sinon, on initialise une nouvelle liste avec le suffixe comme premier élément.

Ce code construit et renvoie la liste d'adjacence du graphe de de Bruijn sous forme de dictionnaire normal, sans utiliser `defaultdict`.